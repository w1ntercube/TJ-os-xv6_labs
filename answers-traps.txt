Q1 哪些寄存器中存放方法中的参数？例如哪个寄存器保存main调用print打印的13？
A1 阅读代码call.asm 文件void main 部分关于print方法的代码：
 
得知，a0-a7保存了方法中的参数，调用printf方法时，13被a2寄存器保存
Q2 汇编代码中的main在哪里调用了方法f，在哪里调用了g？（提示：编译器可能会内链函数）
A2 阅读函数f和g，f调用g，g使传入的参数加3后返回：
 
所以，main没有调用f和g方法，编译器对其进行了优化
Q3 函数printf的地址是什么？
A3 容易找到printf方法的位置：
 
得知，地址为0x62
Q4 在主函数中执行jalr指令跳转到printf之后，寄存器ra中的值是什么？
A4 aupic 和 jalr配合，可以跳转任意32位地址：
 
得知，使用 auipc ra,0x0 将当前程序计数器 pc 的值存入 ra 中，使用jalr 1554(ra) 跳转到偏移地址 printf 处，也就是 0x642 的位置。执行完后，ra值设置为pc+4，也就是0x38
Q5 运行以下代码，输出是什么？
unsigned int i = 0x00646c72;
printf("H%x Wo%s", 57616, &i);
A5 由于 RISC-V 是小端序，这意味着字节顺序是反向存储的。
0x00646c72 存储为：72 6c 64 00
"H%x" 会输出十六进制数 57616，对应十六进制值是 0xe110。
"Wo%s" 会输出从 i 开始的字符串，这里 &i 指向的内存内容是 72 6c 64 00，即 rld。
因此小端序输出：he110 World
如果 RISC-V 是大端序，为了得到相同的输出，我们需要调整 i 的值。
0x00646c72 应该存储为：00 64 6c 72
为了让 &i 指向的字符串仍然是 rld，需要将 i 设置为 0x726c6400。
至于 57616 的值，它仅影响十六进制的部分输出，与端序无关，因此不需要更改。
因此，在大端序下，i 应设置为 0x726c6400，57616 的值不需要改变。
输出结果仍然是：he110 World
Q6 下面的代码中什么会打印在y=的后面（答案不是一个特殊值）。为什么会发生这种情况？
printf("x=%d y=%d", 3)
A6 函数的参数是通过寄存器a1, a2 等来传递。如果 prinf 少传递一个参数，那么其仍会从一个确定的寄存器中读取其想要的参数值，但是我们并没有给出这个确定的参数并将其存储在寄存器中，所以函数将从此寄存器中获取到一个随机的不确定的值作为其参数。因此，y=后面的值不能够确定，它是一个垃圾值。
